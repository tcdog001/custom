#!/bin/bash

if [[ -n "${__UPGRADE_DIR_IN__}" ]]; then
	return
else
	__UPGRADE_DIR_IN__="$0"
fi

. ${__ROOTFS__}/etc/utils/utils.in

readonly -A dev_emmc_bin=(
	[fastboot-burn.bin]=/dev/mmcblk0p1
	[pq_param_hi3718cv100.bin]=/dev/mmcblk0p4
	[hi_kernel.bin]=/dev/mmcblk0p6
)

readonly -A DEV_ROOTFS=(
	["/dev/mmcblk0p7"]=0
	["/dev/mmcblk0p8"]=1
	["/dev/mmcblk0p9"]=2
)

init_dir_status() {
	set_file_value ${file_status_3g} ${LINK_DOWN}
	set_file_value ${file_status_5g} ${LINK_DOWN}
}

#
# get current rootfs's dev
#
dev_rootfs_current() {
	#
	# get from cache
	#
	local dev=$(getfilevalue ${file_dev_current} "")
	case ${dev} in
	/dev/mmcblk0p[7-9])
		echo ${dev}
		return
		;;
	esac

	#
	# get from /proc/cmdline
	#
	local dev=$(cat /proc/cmdline | sed 's# #\n#g' | grep root= | awk -F '=' '{print $2}')
	if [[ -z "${dev}" ]]; then
		return ${e_noexist}
	else
		#
		# save to cache
		#
		echo ${dev}

		set_file_value ${file_dev_current} ${dev}
	fi
}

#
# get current rootfs's idx
#
rootfs_current() {
	#
	# get from cache
	#
	local idx=$(getfilevalue ${file_rootfs_current} "")
	case ${idx} in
	0 | 1 | 2)
		echo ${idx}
		return
		;;
	esac

	local dev=$(dev_rootfs_current)
	idx=${DEV_ROOTFS[${dev}]}
	if [[ -z "${dev}" || -z "${idx}" ]]; then
		#
		# error, bad cmdline
		#
		echo 0

		return ${e_noexist}
	else
		#
		# save to cache
		#
		echo ${idx}

		set_file_value ${file_rootfs_current} ${idx}
	fi
}

#
# get buddy rootfs's idx
#[$1:idx]
#
# rootfs_buddy ==> rootfs_current's buddy
# rootfs_buddy 1 ==> rootfs1's buddy ==>2
# rootfs_buddy 2 ==> rootfs2's buddy ==>1
#
rootfs_buddy() {
	local idx=$1; idx=${idx:-$(rootfs_current)}

	case ${idx} in
	2)
		echo 1
		;;
	1)
		echo 2
		;;
	0 | *)
		echo 1

		return ${e_inval}
		;;
	esac
}

#
#[$1:idx]
#
rootfs_dev() {
	local idx="$1"; idx=${idx:-$(rootfs_current)}
	local dev=dev_rootfs${idx}
	echo "${!dev}"
}

#
#[$1:idx]
#
rootfs_dir() {
#	local idx="$1"; idx=${idx:-$(rootfs_current)}
#	local dir=dir_rootfs${idx}
#	echo "${!dir}"

	local idx="$1"

	if [[ -n "${idx}" && "${idx}" != "$(rootfs_current)" ]]; then
		local dir=dir_rootfs${idx}

		echo ${!dir}
	fi
}

#
#$1:dev name
#$2:dev alias
#[$3:retry...]
#
wait_dev() {
	local dev="$1"
	local alias="$2"
	local retry="$3"; retry=${retry:-3}

	local times
	for ((times=0; times<retry; times++)); do
		ls ${dev} &> /dev/null && return

		echo "wait for ${alias} ..."
		sleep 1
	done

	return ${e_noexist}
}

#
#$1:dev
#
__dev_exist() {
	local dev="$1"

	if [[ -n "$(cat /proc/partitions | grep $(basename ${dev}))" ]]; then
		echo yes
	else
		echo no
	fi
}

#
#$1:dev
#
__dev_mounted() {
	local dev="$1"

	if [[ "yes" == "$(__dev_exist ${dev})" && -n "$(mount | grep ${dev})" ]]; then
		echo yes
	else
		echo no
	fi
}

#
#$1:dev name
#$2:dir name
#[$3:opt]
#
do_mount() {
	local dev="$1"
	local dir="$2"; shift 2
	local opt="$*"
	local opt_fixed="-t ext4 -o noatime,nodiratime"

	if [[ "yes" == "$(__dev_mounted ${dev})" ]]; then
		#
		# if have mounted, do nothing
		#
		echo "${dev} have mounted"

		return
	elif [[ "${dev}" != "$(dev_rootfs_current)" ]]; then
		do_with_cb logger:echo_logger "fsck" \
			"fsck.ext4 -p ${dev}"
	fi

	do_with_cb logger:echo_logger "mount" \
		"mount ${opt} ${opt_fixed} ${dev} ${dir}"
}

#
#$1:dev/dir
#
do_umount() {
	local dev="$1"

	if [[ "yes" == "$(__dev_mounted ${dev})" ]]; then
		do_with_cb :logger "umount" \
			"umount -r ${dev}"
	fi
}

mount_sd() {
	wait_dev ${dev_sd} sd 2 || return $?

	do_mount ${dev_sd} ${dir_sd}

	#
	# ptest MUST run front-end
	#
	local ptest=${dir_sd}/product_test.sh
	if [[ -x "${ptest}" ]]; then
		echo_logger "mount" \
			"found and exec ${ptest}"

		${ptest}
	fi
}

umount_sd() {
	do_umount ${dev_sd}
}

mount_hd() {
	wait_dev ${dev_hd} hd 3 || return $?

	do_mount ${dev_hd} ${dir_hd} || return $?

	if [[ -d "${dir_cp_website}" ]]; then
		chmod -R 777 ${dir_cp_website}
	fi

	setup_dir_with_prefix dir_ ${dir_hd}
	#
	# link /mnt/hd/custom/${__CP__} to /data/${__CP__}
	#
	LN_DIR ${dir_cp} ${__CP_HOME__}

	usr/sbin/sysled sata on
}

umount_hd() {
	do_umount ${dev_hd}
}

mount_usb() {
	wait_dev ${dev_usb} usb 2 || return $?

	do_mount ${dev_usb} ${dir_usb} || return $?
}

umount_usb() {
	do_umount ${dev_usb}
}

#
#$1:dev/dir
#
get_mount_opt() {
	local dev="$1"

	local _ opt
	IFS="(," read _ opt _ <<< $(mount | grep ${dev})

	echo ${opt}
}

#
#$1:dir/dev
#$2:ro|rw
#
do_remount() {
	local dir=$1
	local opt=$2

	if [[ "${opt}" != "$(get_mount_opt ${dir})" ]]; then
		do_with_cb :logger "remount" \
			"mount -o ${opt},remount ${dir} &>/dev/null"
	fi
}

#
#$1:idx
#$2:opt
#
remount_rootfs() {
	local idx=$1
	local opt=$2
	local current=$(rootfs_current)

	if ((idx != current)); then
		do_remount $(rootfs_dir ${idx}) ${opt}
	fi
}

mount_rootfs() {
	local idx
	local current=$(rootfs_current)

	#
	# skip current rootfs
	#
	for ((idx=0; idx<3; idx++)); do
		#
		# cannot use as below
		#   for ((idx=0; idx<3 && idx != current; idx++)); do
		#
		if ((idx == current)); then
			continue
		fi

		local dev=$(rootfs_dev ${idx})
		local dir=$(rootfs_dir ${idx})
		local alias=rootfs${idx}

		wait_dev ${dev} ${alias} 3 || {
			echo_logger mount \
				"no found ${dev}"

			continue
		}

		local opt="" #re-init to empty in loop
		if ((0==idx)); then
			opt="-r" # rootfs0 is readonly
		fi

		do_mount ${dev} ${dir} ${opt}
	done
}

umount_rootfs() {
	local idx
	local current=$(rootfs_current)

	#
	# skip current rootfs
	#
	for ((idx=0; idx<3; idx++)); do
		if ((idx == current)); then
			continue
		fi

		do_umount $(rootfs_dev ${idx})
	done
}

init_dir_config() {
	do_nothing
}

init_dir_tftp() {
	#
	# link ap boot
	#
	LN_FILE ${dir_rootfs0}/image/${file_ap_boot} ${dir_tftp}/${file_ap_boot}
	#
	# link ap file(for ap super recover)
	#
	LN_FILE ${dir_rootfs0}/image/${file_ap} ${dir_tftp}/${file_ap_long}
	#
	# link ap file(for ap upgrade)
	#
	LN_FILE ${__ROOTFS__}/image/${file_ap} ${dir_tftp_version}/${file_ap}
}

#
# opt dir ==> tftp dir
#
opt2tftp() {
	#
	# convert opt dir to tftp dir
	# 	${dir_opt} and ${dir_tftp} have same sub dir
	#
	local opt
	for opt in $(find ${dir_opt} -type d); do
		local dir=$(sed "s#${dir_opt}#${dir_tftp}#" <<< ${opt})

		MKDIR ${dir}
	done
}

setup_data_dir() {
	setup_dir_with_prefix dir_ ${dir_rootfs_data}
}

setup_tmp_dir() {
	setup_dir_with_prefix dir_ /tmp
	opt2tftp
}

init_log() {
	local now=$(getnow)
	local file

	#
	# save md init info
	#
	file=${dir_opt_log_sys_md_init}/${now}
	dmesg > ${file}; fsync ${file}

	#
	# start syslogd, log at rootfs_data
	#	Max size (1024KB) before rotate
	#
	file=${dir_opt_log_sys_md_ulog}/${now}; touch ${file}
	rm -f ${file_md_ulog}
	LN_FILE ${file} ${file_md_ulog}
	syslogd -s 1024 -O ${file}

	#
	# todo: how to save /proc/kmsg
	#
}

init_dev_rootfs_data() {
	setup_data_dir
	init_log
	init_dir_config
}

init_dev_tmp() {
	setup_tmp_dir
	init_dir_tftp
	init_dir_status
}

#
#$1:idx
#
mount_rootfs_data() {
	local err=0

	wait_dev ${dev_rootfs_data} data 2
	do_mount ${dev_rootfs_data} ${dir_rootfs_data}

	init_dev_rootfs_data
	init_dev_tmp
}

umount_rootfs_data() {
	do_umount ${dev_rootfs_data}
}

mount_all() {
	mount_rootfs_data
	mount_rootfs
	mount_sd
	mount_hd
	mount_usb
}

umount_all() {
	umount_usb
	umount_hd
	umount_sd
	umount_rootfs
	umount_rootfs_data
}
