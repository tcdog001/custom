#!/bin/bash

if [[ -n "${__UPGRADE_RSYNC_IN__}" ]]; then
	return
else
	__UPGRADE_RSYNC_IN__="$0"
fi

. ${__ROOTFS__}/etc/jsock/jsock.in
. ${__ROOTFS__}/etc/upgrade/dir.in

#
#$1:version
#
rsync_version_dir() {
	local version="$1"

	echo ${dir_md_rsync}/${version}
}

#
#$1:version
#
rsync_rootfs_dir() {
	local version="$1"

	echo $(rsync_version_dir ${version})/rootfs
}

#
#[$1:idx]
#
# rootfs_version_file ==> /etc/.version
# rootfs_version_file x ==> /rootfsX/etc/.version
#
rootfs_version_file() {
	local idx=$1; idx=${idx:-$(rootfs_current)}

	echo "$(rootfs_dir ${idx})/etc/.version"
}

#
#[$1:idx]
#
buddy_version_file() {
	local idx=$1; idx=${idx:-$(rootfs_current)}

	echo "$(rootfs_dir ${idx})/etc/.buddy_version"
}

#
#[$1:idx]
#
rootfs_verfy_file() {
	local idx=$1; idx=${idx:-$(rootfs_current)}

	echo "$(rootfs_dir ${idx})/etc/.upgrade_verfy"
}

#
#[$1:idx]
#
# get_rootfs_version ==> get current rootfs's version
# get_rootfs_version x ==> get rootfsX's version
#
get_rootfs_version() {
	local idx=$1

	local file=$(rootfs_version_file ${idx})
	echo "$(get_file_value ${file})"
}

#
#[$1:idx]
#
# get_buddy_version ==> get current rootfs's buddy_version
# get_buddy_version x ==> get rootfsX's buddy_version
#
get_buddy_version() {
	local idx=$1

	local file=$(buddy_version_file ${idx})
	echo "$(get_file_value ${file})"
}

#
#$1:version
#[$2:idx]
#
# set_buddy_version version ==> set current rootfs's buddy_version
# set_buddy_version version x ==> set rootfsX's buddy_version
#
set_buddy_version() {
	local version=$1
	local idx=$2

	local file=$(buddy_version_file ${idx})
	set_file_value ${file} ${version}
}

#
# rsync dir/	-->dir_ap_rsync/a.b.c.d  or dir_md_rsync/a.b.c.d/
#	fsm		-->ap/md rsync fsm, need|rsyncing|ok, init with ok
#	state	-->ap/md upgrade state, need|upgrading|verfy|ok|fail, init with ok
#	error	-->ap/md rsync error code, 0 is ok
#	log		-->ap/md logs, append line
#
#
#	fsm
#		'need'
#			after get rsync command from cloud
#			before start rsync task
#			set fsm to need
#		'rsyncing'
#			rsync task init, set fsm to rsyncing
#		'ok'
#			rsync task success, set fsm to ok
#
#
#
#	error:
#		0: rsync task success, set error to 0
#		other: rsync task normal exit with error, set error to rsync error code
#
#	rsync_log: line format [time version action error]
#		time: like 2014.09.17-15:09:51
#		action:
#			cloud: get rsync command from cloud
#			begin: begin rsync task
#			normal: rsync task normal exit with error-code
#			abnormal: rsync task abnormal
#			check: fsm abnormal, kill rsync task
#		error: error code
#			when action is normal
#				0: success
#				other: rsync error code
#			when action is check
#				e_rsync_check_ready_running
#					ok+running, kill rsync task
#				e_rsync_check_need_running
#					need+running, kill rsync task
#				e_rsync_check_need_notrunning
#					neeed+not running
#				e_rsync_check_rsyncing_running
#					rsyncing+running
#

rsync_debug_ok() {
	debug_echo rsync __all__ __ok__ "$@"
}

rsync_debug_error() {
	debug_echo rsync __all__ __error__ "$@"
}

rsync_debug_trace() {
	debug_echo rsync __all__ __trace__ "$@"
}

rsync_logger() {
	do_logger rsync "$@"
}

rsync_echo_logger() {
	echo_logger rsync "$@"
}

rsync_rootfs0_check() {
	local current=$(rootfs_current)

	if ((0==current)); then
		upgrade_debug_error "rootfs0 not support rsync"

		return ${e_nosupport}
	fi
}

#
#$1:action
#
rsync_do() {
	debug_do rsync "$@"
}

readonly file_rsync_timeout=/data/rsync/.rsync_timeout
get_rsync_timeout_seconds() {
	echo "$(getfilevalue ${file_rsync_timeout} 300)"
}

readonly file_rsync_version_limit=/data/rsync/.rsync_version_limit
get_rsync_version_limit() {
	echo "$(getfilevalue ${file_rsync_version_limit} 5)"
}

readonly file_lock_rsync_task=/tmp/.rsync_task.lock
rsync_task_running() {
	local err=0

	exec_with_flock ${file_lock_rsync_task} echo; err=$?
	if ((e_flock_failed == err)); then
		echo 'running'
	fi
}

#
#$1:version
#$2:filename
#
rsync_file() {
	local version="$1"
	local file="$2"

	echo $(rsync_version_dir ${version})/${filename}
}

#
#$1:version
#
rsync_logfile() {
	local version="$1"

	echo "$(rsync_file ${version} 'log')"
}

#
#$1:version
#$2:action
#$3:errno
#$4:log...
#
rsync_log() {
	local version="$1"
	local action="$2"
	local errno="$3"; shift 3
	local log="$*"

	local file=$(rsync_logfile ${version})

	echo "$(getnow)" "${version}" "${action}" "${errno}" "${log}" >> ${file}
	fsync ${file}
}

#
#$1:version
#$2:filename
#[$3:value...]
#
rsync_value() {
	local version="$1"
	local filename="$2"; shift 2
	local value="$*"

	if [[ -z "${version}" || -z "${filename}" ]]; then
		return ${e_inval}
	fi

	local file=$(rsync_file ${version} ${filename})

	if [[ -z "${value}" ]]; then
		if [[ -f "${file}" ]]; then
			#
			# get
			#
			cat ${file}
		else
			return ${e_noexist}
		fi
	else
		#
		# set
		#
		echo ${value} > ${file}; fsync ${file}
	fi
}

#
#$1:version
#$2:filename
#
rsync_getvalue() {
	local version="$1"
	local filename="$2"

	echo $(rsync_value ${version} ${filename})
}

#
#$1:version
#$2:filename
#$3:value...
#
rsync_setvalue() {
	local version="$1"
	local filename="$2"; shift 2
	local value="$*"

	rsync_value "${version}" "${filename}" "${value}"
}


get_rsync_version_list() {
	echo "$(ls ${dir_md_rsync})"
}

get_rsync_version_list_skip0() {
	local list=$(get_rsync_version_list)
	local skip=$(get_rootfs_version 0)

	#
	# skip rootfs0's version
	#
	echo "${list//${skip}}"
}

#
#$1:version
#
rsync_delete_version() {
	local version="$1"
	local dir=$(rsync_version_dir ${version})

	rm -fr ${dir}
	rsync_echo_logger "rsync_version_delete" \
		"delete rsync version:${version}"
}

rsync_limit_version_count() {
	#
	# skip rootfs0's version
	#
	local list="$(get_rsync_version_list_skip0)"
	local count=$(get_version_count ${list})
	local limit=$(get_rsync_version_limit)
	local version

	while ((count > limit)); do
		version=$(get_min_version ${list})

		rsync_echo_logger "rsync_limit_version_count" \
			"rsync version list:${list}"
		rsync_echo_logger "rsync_limit_version_count" \
			"rsync version limit:${limit} count:${count}"

		rsync_delete_version ${version}

		#
		# skip rootfs0's version
		#
		list="$(get_rsync_version_list_skip0)"
		count=$(get_version_count ${list})
	done
}

#
#$1:src
#$2:dst
#
rsync_copy() {
	local src="$1"
	local dst="$2"
	local err=0

	#
	# if src is dir, must end with /
	#
	if [[ -d "${src}" ]]; then
		src=${src%/}/
	fi

	rsync -acq --delete --force ${src} ${dst} &> /dev/null; err=$?; sync
	rsync_logger "$(get_error_tag ${err}):rsync copy ${src} to ${dst}"

	return ${err}
}

#
# setup first md rsync version by rootfsX
#
#$1:idx
#
rsync_setup_by() {
	local idx="$1"
	if [[ "${idx}" == "$(rootfs_current)" ]]; then
		return ${e_nosupport}
	fi

	local version="$(get_rootfs_version ${idx})"
	local src="$(rootfs_dir ${idx})"
	local dst="$(rsync_rootfs_dir ${version})"
	local err

	if ((0==idx)); then
		remount_rootfs 0 rw
	fi
	MKDIR ${dst}
	rsync_copy ${src} ${dst}; err=$?
	if ((0==idx)); then
		remount_rootfs 0 ro
	fi
	if ((0!=err)); then
		rsync_debug_error "copy ${src} to ${dst} failed:${err}"

		return ${err}
	fi

	rsync_setvalue ${version} error 0
	rsync_setvalue ${version} fsm ok
	rsync_setvalue ${version} state ok

	rsync_echo_logger "setup first rsync version:${version}"
}

#
#$1:version
#$2:acc
#
newest_version_filter() {
	local version="$1"
	local acc="$2"

	local state="$(rsync_getvalue ${version} state)"
	local compare="$(version_compare ${version} ${acc})"

	rsync_debug_trace "newest_version_filter" \
		"version:${version} acc:${acc} compare:${compare} state:${state}"

	if [[ "gt" == "${compare}" && "ok" == "${state}" ]]; then
		echo "${version}"
	else
		echo "${acc}"
	fi
}

__rsync_newest_version() {
	local list="$(get_rsync_version_list)"
	local version="$(get_version_byfilter $(version_min) newest_version_filter ${list})"

	#
	# cannot rsync_echo_logger
	#
	rsync_logger ${FUNCNAME} \
		"newest version:${version} from list:${list}"

	echo "${version}"
}

rsync_newest_version() {
	local newest="$(__rsync_newest_version)"

	if [[ -z "${newest}" && "0" != "$(rootfs_current)" ]]; then
		echo $(rsync_setup_by 0) &> /dev/null

		newest="$(__rsync_newest_version)"
	fi

	echo "${newest}"
}

#
# atbus.autelan.com ==> 182.254.198.168
#
readonly -A deft_rsync=(
	[server]=atbus.autelan.com
	[path]=/opt/version/lte-fi/mdboard
	[port]=873
	[user]=root
	[pass]=ltefi@Autelan1
)

readonly version_rootfs_readonly=1.0.3.0
#
#$1:version
#
rsync_task() {
	local version="$1"
	local json=$(rsync_getvalue ${version} json)

	rsync_echo_logger ${FUNCNAME} "version ${version}..."

	json_check "${json}" || {
		rsync_debug_error ${FUNCNAME} "bad json:${json}"

		return ${e_rsync_bad_json}
	}

	local jversion="$(echo ${json} | jq -j '.version|strings')"
	if [[ ${version} != "${jversion}" ]]; then
		rsync_debug_error ${FUNCNAME} \
			"version ${version} not match json version ${jversion}"

		return ${e_rsync_bad_version}
	fi

	#
	# try upgrade current-version ==> version
	#   current version < version_rootfs_readonly
	#   version >= version_rootfs_readonly
	#   NOT support
	#
#	local current_version=$(get_rootfs_version)
#	if [[ "lt" == "$(version_compare ${current_version} ${version_rootfs_readonly})" \
#	   && "lt" != "$(version_compare ${version} ${version_rootfs_readonly})" ]]; then
#		rsync_echo_logger ${FUNCNAME} \
#			"no supprot upgrade from ${current_version} to ${version}"
#
#		return ${e_nosupport}
#	fi

	local server=$(echo ${json} | jq -j '.server|strings')
	if [[ -z "${server}" ]]; then
		server=${deft_rsync[server]}
		rsync_debug_trace ${FUNCNAME} "use default server:${server}"
	fi

	local path=$(echo ${json} | jq -j '.path|strings')
	if [[ -z "${path}" ]]; then
		path=${deft_rsync[path]}
		rsync_debug_trace ${FUNCNAME} "use default path:${path}"
	fi
	#
	# path NOT include version/rootfs
	#
	if [[ "${path}" == "${path%rootfs}" || "${path}" == "${path%rootfs/}" ]]; then
		path=${path}/${version}/rootfs/
	fi

	local port=$(echo ${json} | jq -j '.port|strings')
	if [[ -z "${port}" ]]; then
		port=${deft_rsync[port]}
		rsync_debug_trace ${FUNCNAME} "use default port:${port}"
	fi

	local user=$(echo ${json} | jq -j '.user|strings')
	if [[ -z "${user}" ]]; then
		user=${deft_rsync[user]}
		rsync_debug_trace ${FUNCNAME} "use default user:${user}"
	fi

	local pass=$(echo ${json} | jq -j '.pass|strings')
	if [[ -z "${pass}" ]]; then
		pass=${deft_rsync[pass]}
		rsync_debug_trace ${FUNCNAME} "use default pass:${pass}"
	fi

	local fsm="$(rsync_getvalue ${version} fsm)"
	local error="$(rsync_getvalue ${version} error)"
	rsync_echo_logger ${FUNCNAME} "start with fsm:${fsm} error:${error}"

	#
	# check fsm
	#
	case "${fsm}" in
	"ok")
		#
		# needn't rsync
		#
		rsync_echo_logger "the rsync version:${version} is ok, start upgrade"

		${__ROOTFS__}/etc/upgrade/upgrade_task.sh "${version}"

		return
		;;
	"rsyncing")
		if [[ "0" == "${error}" ]]; then
			#
			#maybe rsync task abnormal exit
			#
			rsync_log "${version}" "check" "${e_rsync_last_abnormal}"
		else
			#
			#last rsync task normal exit with error
			#
			do_nothing
		fi
		;;
	"need")
		do_nothing
		;;
	"")
		#
		# handle as need
		# todo log
		;;
	*)
		#
		# handle as need
		# todo log
		;;
	esac

	#
	# must end with /
	#
	# ${path%/}==>try remove last /
	#	/a/b/c/==>/a/b/c
	#	/a/b/c ==>/a/b/c
	#
	local remote=${path%/}/
	local dir="$(rsync_rootfs_dir ${version})"
	local timeout=$(get_rsync_timeout_seconds)
	#
	# -a, --archive     	归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD
	# -r, --recursive		对子目录以递归模式处理
	# -l, --links     		保留软链结
	# -p, --perms    		保持文件权限
	# -t, --times         	保持文件时间信息
	# -g, --group    		保持文件属组信息
	# -o, --owner    		保持文件属主信息
	# -D, --devices 		保持设备文件信息
	#
	# -c, --checksum		打开校验开关，强制对文件传输进行校验
	# -z, --compress 		对备份的文件在传输时进行压缩处理
	# -v, --verbose 		详细模式输出
	#
	# -I, --ignore-times	不跳过那些有同样的时间和长度的文件
	# --size-only         	当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间
	# --delete      		删除那些DST中SRC没有的文件
	# --force       		强制删除目录，即使不为空
	# --block-size=SIZE		检验算法使用的块尺寸，默认是700字节
	# --rsh=COMMAND 		指定使用rsh、ssh方式进行数据同步
	# --timeout=TIME		超时时间，单位为秒
	# --bwlimit=KBPS   		限制I/O带宽，KBytes per second
	# --partial          	保留那些因故没有完全传输的文件，以是加快随后的再次传输
	#
	local sshparam="sshpass -p ${pass} ssh -l ${user} -o StrictHostKeyChecking=no"
	local rsync_dynamic="--rsh=\"${sshparam}\" --timeout=${timeout}"
	local rsync_static="-acz --delete --force --stats --partial"
	local rsyncaction="rsync ${rsync_dynamic} ${rsync_static} ${server}:${remote} ${dir}"
	local err=0

	rsync_echo_logger ${FUNCNAME} "rsyncaction=${rsyncaction}"

	rsync_setvalue ${version} fsm rsyncing
	rsync_setvalue ${version} error 0
	rsync_do "${rsyncaction}"; err=$?
	rsync_setvalue ${version} error ${err}

	if [[ "0" != "${err}" ]]; then
		rsync_echo_logger ${FUNCNAME} "rsync error=${err}"

		return ${e_rsync_abnormal}
	fi

	#
	# rsync ok
	#
	rsync_setvalue ${version} fsm ok
	#
	# prepare upgrade
	#
	rsync_setvalue ${version} state need
	rsync_echo_logger ${FUNCNAME} "version:${version} ok, start upgrade"

	${__ROOTFS__}/etc/upgrade/upgrade_task.sh "${version}"

	return ${err}
}

rsync_auto() {
	local list="$(get_rsync_version_list)"
	local version

	rsync_logger "rsync_auto" "..."

	for version in ${list}; do
		local fsm="$(rsync_getvalue ${version} fsm)"
		local state="$(rsync_getvalue ${version} state)"

		if [[ "need" == "${fsm}" || "rsyncing" == "${fsm}" ]]; then
			rsync_logger ${FUNCNAME} \
			 	"start with version:${version} fsm:${fsm} state:${state}"

			rsync_task ${version}
		fi
	done
}

#
#$1:json
#
rsync_start() {
	local json="$*"
	local safejson="$(echo ${json} | jq 'del(.pass)')"
	local err

	rsync_logger "rsync_start" \
		"json ${safejson}..."

	local version=$(echo ${json} | jq -j '.version|strings')
	version_check ${version} || {
		rsync_debug_error "rsync_start" \
			"bad version ${version}"

		return ${e_rsync_bad_version}
	}
	if [[ "${version}" == "$(get_rootfs_version)" ]]; then
		rsync_echo_logger "input version:${version}==rootfs version, needn't rsync"

		return
	fi

	local dir="$(rsync_rootfs_dir ${version})"
	#
	# version is exist
	#
	if [[ -d "${dir}" ]]; then
		local base_setuped=0
		local fsm="$(rsync_getvalue ${version} fsm)"
		local state="$(rsync_getvalue ${version} state)"

		if [[ -z "${fsm}" ]]; then
			#
			# have NOT setup rsync base version
			#	but the rsync is break
			#
			rm -fr $(rsync_version_dir ${version}); sync
		else
			#
			# have setup rsync base version
			#	but the rsync is break
			#
			# todo: check state is ok ???
			#
			rsync_echo_logger "rsync_start" \
				"exist version:${version} with fsm:${fsm} state:${state}"
		fi
	fi

	#
	# version is NOT exist
	#
	if [[ ! -d "${dir}" ]]; then
		local newest="$(rsync_newest_version)"
		if [[ -z "${newest}" ]]; then
			rsync_debug_error "rsync_start" \
				"no found version ${version} and no found newest"

			return ${e_rsync_no_version}
		fi

		rsync_echo_logger "rsync_start: setup rsync base version by ${newest}..."
		#
		# use newest as rsync base version
		#
		local newestdir="$(rsync_rootfs_dir ${newest})"
		MKDIR ${dir}
		cp -fpR ${newestdir}/* ${dir}; sync
		#
		# todo: check
		#
		rsync_echo_logger "rsync_start" \
			"setup rsync base version by ${newest} ok"

		rsync_setvalue ${version} error 0
		rsync_setvalue ${version} fsm need
	fi
	#
	# save json
	#
	rsync_setvalue ${version} json ${json}

	rsync_task ${version}; err=$?
	rsync_echo_logger ${FUNCNAME} "err:${err}"
}

do_rsync() {
	local json="$*"

	if [[ -z "${json}" ]]; then
		#
		# start by auto
		#
		rsync_auto
	else
		#
		# start by cloud/manual
		#
		rsync_start "${json}"
	fi
}

#
#	rsync start, after get rsync command from cloud
#	input:
#	$1:{"version":"xxx","server":"xxx","port":"xxx","path":"xxx","user":"xxx","pass":"xxx"}
#
#
rsync_with_flock() {
	exec_with_flock ${file_lock_rsync_task} do_rsync "$*" || return $?
}